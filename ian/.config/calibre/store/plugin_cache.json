{
  "manybooks": "# -*-\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nstore_version = 2  # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2011, John Schember <john@nachtimwald.com>'\n__docformat__ = 'restructuredtext en'\n\nimport mimetypes\nfrom contextlib import closing\n\nfrom lxml import etree\n\nfrom calibre import browser\nfrom calibre.gui2.store.basic_config import BasicStoreConfig\nfrom calibre.gui2.store.opensearch_store import OpenSearchOPDSStore\nfrom calibre.gui2.store.search_result import SearchResult\nfrom calibre.utils.opensearch.description import Description\nfrom calibre.utils.opensearch.query import Query\n\n\ndef search_manybooks(query, max_results=10, timeout=60, open_search_url='http://www.manybooks.net/opds/'):\n    '''\n    Manybooks uses a very strange opds feed. The opds\n    main feed is structured like a stanza feed. The\n    search result entries give very little information\n    and requires you to go to a detail link. The detail\n    link has the wrong type specified (text/html instead\n    of application/atom+xml).\n    '''\n\n    description = Description(open_search_url)\n    url_template = description.get_best_template()\n    if not url_template:\n        return\n    oquery = Query(url_template)\n\n    # set up initial values\n    oquery.searchTerms = query\n    oquery.count = max_results\n    url = oquery.url()\n\n    counter = max_results\n    br = browser()\n    with closing(br.open(url, timeout=timeout)) as f:\n        raw_data = f.read()\n        raw_data = raw_data.decode('utf-8', 'replace')\n        doc = etree.fromstring(raw_data, parser=etree.XMLParser(recover=True, no_network=True, resolve_entities=False))\n        for data in doc.xpath('//*[local-name() = \"entry\"]'):\n            if counter <= 0:\n                break\n\n            counter -= 1\n\n            s = SearchResult()\n\n            detail_links = data.xpath('./*[local-name() = \"link\" and @type = \"text/html\"]')\n            if not detail_links:\n                continue\n            detail_link = detail_links[0]\n            detail_href = detail_link.get('href')\n            if not detail_href:\n                continue\n\n            s.detail_item = 'http://manybooks.net/titles/' + detail_href.split('tid=')[-1] + '.html'\n            # These can have HTML inside of them. We are going to get them again later\n            # just in case.\n            s.title = ''.join(data.xpath('./*[local-name() = \"title\"]//text()')).strip()\n            s.author = ', '.join(data.xpath('./*[local-name() = \"author\"]//text()')).strip()\n\n            # Follow the detail link to get the rest of the info.\n            with closing(br.open(detail_href, timeout=timeout/4)) as df:\n                ddoc = etree.fromstring(df.read(), parser=etree.XMLParser(recover=True, no_network=True, resolve_entities=False))\n                ddata = ddoc.xpath('//*[local-name() = \"entry\"][1]')\n                if ddata:\n                    ddata = ddata[0]\n\n                    # This is the real title and author info we want. We got\n                    # it previously just in case it's not specified here for some reason.\n                    s.title = ''.join(ddata.xpath('./*[local-name() = \"title\"]//text()')).strip()\n                    s.author = ', '.join(ddata.xpath('./*[local-name() = \"author\"]//text()')).strip()\n                    if s.author.startswith(','):\n                        s.author = s.author[1:]\n                    if s.author.endswith(','):\n                        s.author = s.author[:-1]\n\n                    s.cover_url = ''.join(ddata.xpath('./*[local-name() = \"link\" and @rel = \"http://opds-spec.org/thumbnail\"][1]/@href')).strip()\n\n                    for link in ddata.xpath('./*[local-name() = \"link\" and @rel = \"http://opds-spec.org/acquisition\"]'):\n                        type = link.get('type')\n                        href = link.get('href')\n                        if type:\n                            ext = mimetypes.guess_extension(type)\n                            if ext:\n                                ext = ext[1:].upper().strip()\n                                s.downloads[ext] = href\n\n            s.price = '$0.00'\n            s.drm = SearchResult.DRM_UNLOCKED\n            s.formats = 'EPUB, PDB (eReader, PalmDoc, zTXT, Plucker, iSilo), FB2, ZIP, AZW, MOBI, PRC, LIT, PKG, PDF, TXT, RB, RTF, LRF, TCR, JAR'\n\n            yield s\n\n\nclass ManyBooksStore(BasicStoreConfig, OpenSearchOPDSStore):\n\n    open_search_url = 'http://www.manybooks.net/opds/'\n    web_url = 'http://manybooks.net'\n\n    def search(self, query, max_results=10, timeout=60):\n        for r in search_manybooks(query, max_results=max_results, timeout=timeout, open_search_url=self.open_search_url):\n            yield r\n\n\nif __name__ == '__main__':\n    import sys\n    for result in search_manybooks(' '.join(sys.argv[1:])):\n        print(result)\n", 
  "gutenberg": "# -*-\n# License: GPLv3 Copyright: 2020, Kovid Goyal <kovid at kovidgoyal.net>\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nstore_version = 7  # Needed for dynamic plugin loading\n\nimport mimetypes\n\ntry:\n    from urllib.parse import quote_plus\nexcept ImportError:\n    from urllib import quote_plus\n\nfrom html5_parser import parse\nfrom lxml import etree\n\nfrom calibre import browser\nfrom calibre.gui2 import open_url\nfrom calibre.gui2.store import StorePlugin\nfrom calibre.gui2.store.search_result import SearchResult\nfrom calibre.gui2.store.web_store_dialog import WebStoreDialog\nfrom css_selectors import Select\n\n\ndef absurl(href):\n    if href.startswith('//'):\n        href = 'https:' + href\n    elif href.startswith('/'):\n        href = 'https://www.gutenberg.org' + href\n    return href\n\n\ndef search(query, max_results=10, timeout=60, write_raw_to=None):\n    url = 'https://www.gutenberg.org/ebooks/search/?query={}&submit_search=Search'.format(quote_plus(query))\n\n    counter = max_results\n    br = browser()\n    raw = br.open(url).read()\n\n    if write_raw_to is not None:\n        with open(write_raw_to, 'wb') as f:\n            f.write(raw)\n\n    root = parse(raw)\n    CSSSelect = Select(root)\n    for li in CSSSelect('li.booklink'):\n        if counter <= 0:\n            break\n        counter -= 1\n\n        s = SearchResult()\n        a = next(CSSSelect('a.link', li))\n        s.detail_item = absurl(a.get('href'))\n        s.title = etree.tostring(next(CSSSelect('span.title', li)), method='text', encoding='unicode').strip()\n        s.author = etree.tostring(next(CSSSelect('span.subtitle', li)), method='text', encoding='unicode').strip()\n        for img in CSSSelect('img.cover-thumb', li):\n            s.cover_url = absurl(img.get('src'))\n            break\n\n        # Get the formats and direct download links.\n        details_doc = parse(br.open_novisit(s.detail_item).read())\n        doc_select = Select(details_doc)\n        for tr in doc_select('table.files tr[typeof=\"pgterms:file\"]'):\n            for a in doc_select('a.link', tr):\n                href = a.get('href')\n                type = a.get('type')\n                ext = mimetypes.guess_extension(type.split(';')[0]) if type else None\n                if href and ext:\n                    url = absurl(href.split('?')[0])\n                    ext = ext[1:].upper().strip()\n                    if ext not in s.downloads:\n                        s.downloads[ext] = url\n                    break\n\n        s.formats = ', '.join(s.downloads.keys())\n        if not s.formats:\n            continue\n\n        yield s\n\n\nclass GutenbergStore(StorePlugin):\n\n    def search(self, query, max_results=10, timeout=60):\n        for result in search(query, max_results, timeout):\n            yield result\n\n    def open(self, parent=None, detail_item=None, external=False):\n        url = detail_item or absurl('/')\n        if external:\n            open_url(url)\n            return\n        d = WebStoreDialog(self.gui, url, parent, detail_item)\n        d.setWindowTitle(self.name)\n        d.exec_()\n\n\nif __name__ == '__main__':\n    import sys\n\n    for result in search(' '.join(sys.argv[1:]), write_raw_to='/t/gutenberg.html'):\n        print(result)\n", 
  "xinxii": "# -*-\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nstore_version = 2  # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2011, John Schember <john@nachtimwald.com>'\n__docformat__ = 'restructuredtext en'\n\nfrom contextlib import closing\ntry:\n    from urllib.parse import quote_plus\nexcept ImportError:\n    from urllib import quote_plus\n\nfrom lxml import etree\n\nfrom calibre import browser\nfrom calibre.gui2.store.basic_config import BasicStoreConfig\nfrom calibre.gui2.store.opensearch_store import OpenSearchOPDSStore\nfrom calibre.gui2.store.search_result import SearchResult\n\n\nclass XinXiiStore(BasicStoreConfig, OpenSearchOPDSStore):\n\n    open_search_url = 'https://www.xinxii.com/catalog-search/'\n    web_url = 'https://xinxii.com/'\n\n    # https://www.xinxii.com/catalog/\n\n    def search(self, query, max_results=10, timeout=60):\n        '''\n        XinXii's open search url is:\n        http://www.xinxii.com/catalog-search/query/?keywords={searchTerms}&amp;pw={startPage?}&amp;doc_lang={docLang}&amp;ff={docFormat},{docFormat},{docFormat}\n\n        This url requires the docLang and docFormat. However, the search itself\n        sent to XinXii does not require them. They can be ignored. We cannot\n        push this into the stanard OpenSearchOPDSStore search because of the\n        required attributes.\n\n        XinXii doesn't return all info supported by OpenSearchOPDSStore search\n        function so this one is modified to remove parts that are used.\n        '''\n\n        url = 'https://www.xinxii.com/catalog-search/query/?keywords=' + quote_plus(query)\n\n        counter = max_results\n        br = browser()\n        with closing(br.open(url, timeout=timeout)) as f:\n            doc = etree.fromstring(f.read(), parser=etree.XMLParser(recover=True, no_network=True, resolve_entities=False))\n            for data in doc.xpath('//*[local-name() = \"entry\"]'):\n                if counter <= 0:\n                    break\n\n                counter -= 1\n\n                s = SearchResult()\n\n                s.detail_item = ''.join(data.xpath('./*[local-name() = \"id\"]/text()')).strip()\n\n                for link in data.xpath('./*[local-name() = \"link\"]'):\n                    rel = link.get('rel')\n                    href = link.get('href')\n                    type = link.get('type')\n\n                    if rel and href and type:\n                        if rel in ('http://opds-spec.org/thumbnail', 'http://opds-spec.org/image/thumbnail'):\n                            s.cover_url = href\n                        if rel == 'alternate':\n                            s.detail_item = href\n\n                s.formats = 'EPUB, PDF'\n\n                s.title = ' '.join(data.xpath('./*[local-name() = \"title\"]//text()')).strip()\n                s.author = ', '.join(data.xpath('./*[local-name() = \"author\"]//*[local-name() = \"name\"]//text()')).strip()\n\n                price_e = data.xpath('.//*[local-name() = \"price\"][1]')\n                if price_e:\n                    price_e = price_e[0]\n                    currency_code = price_e.get('currencycode', '')\n                    price = ''.join(price_e.xpath('.//text()')).strip()\n                    s.price = currency_code + ' ' + price\n                    s.price = s.price.strip()\n\n                yield s\n", 
  "ebookshoppe_uk": "# -*-\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nstore_version = 1  # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2011, John Schember <john@nachtimwald.com>'\n__docformat__ = 'restructuredtext en'\n\ntry:\n    from urllib.parse import quote\nexcept ImportError:\n    from urllib2 import quote\nfrom contextlib import closing\n\nfrom lxml import html\n\nfrom qt.core import QUrl\n\nfrom calibre import browser\nfrom calibre.gui2 import open_url\nfrom calibre.gui2.store import StorePlugin\nfrom calibre.gui2.store.basic_config import BasicStoreConfig\nfrom calibre.gui2.store.search_result import SearchResult\nfrom calibre.gui2.store.web_store_dialog import WebStoreDialog\n\n\nclass EBookShoppeUKStore(BasicStoreConfig, StorePlugin):\n\n    def open(self, parent=None, detail_item=None, external=False):\n        url_details = 'http://www.awin1.com/cread.php?awinmid=1414&awinaffid=120917&clickref=&p={0}'\n        url = 'http://www.awin1.com/awclick.php?mid=2666&id=120917'\n\n        if external or self.config.get('open_external', False):\n            if detail_item:\n                url = url_details.format(detail_item)\n            open_url(QUrl(url))\n        else:\n            detail_url = None\n            if detail_item:\n                detail_url = url_details.format(detail_item)\n            d = WebStoreDialog(self.gui, url, parent, detail_url)\n            d.setWindowTitle(self.name)\n            d.set_tags(self.config.get('tags', ''))\n            d.exec_()\n\n    def search(self, query, max_results=10, timeout=60):\n        url = 'http://www.ebookshoppe.com/search.php?search_query=' + quote(query)\n        br = browser()\n        br.addheaders = [(\"Referer\", \"http://www.ebookshoppe.com/\")]\n\n        counter = max_results\n        with closing(br.open(url, timeout=timeout)) as f:\n            doc = html.fromstring(f.read())\n            for data in doc.xpath('//ul[@class=\"ProductList\"]/li'):\n                if counter <= 0:\n                    break\n\n                id = ''.join(data.xpath('./div[@class=\"ProductDetails\"]/'\n                                        'strong/a/@href')).strip()\n                if not id:\n                    continue\n                cover_url = ''.join(data.xpath('./div[@class=\"ProductImage\"]/a/img/@src'))\n                title = ''.join(data.xpath('./div[@class=\"ProductDetails\"]/strong/a/text()'))\n                price = ''.join(data.xpath('./div[@class=\"ProductPriceRating\"]/em/text()'))\n                counter -= 1\n\n                s = SearchResult()\n                s.cover_url = cover_url\n                s.title = title.strip()\n                s.price = price\n                s.drm = SearchResult.DRM_UNLOCKED\n                s.detail_item = id\n\n                self.get_author_and_formats(s, timeout)\n                if not s.author:\n                    continue\n\n                yield s\n\n    def get_author_and_formats(self, search_result, timeout):\n        br = browser()\n        with closing(br.open(search_result.detail_item, timeout=timeout)) as nf:\n            idata = html.fromstring(nf.read())\n            author = ''.join(idata.xpath('//div[@id=\"ProductOtherDetails\"]/dl/dd[1]/text()'))\n            if author:\n                search_result.author = author\n            formats = idata.xpath('//dl[@class=\"ProductAddToCart\"]/dd/'\n                                  'ul[@class=\"ProductOptionList\"]/li/label/text()')\n            if formats:\n                search_result.formats = ', '.join(formats)\n            search_result.drm = SearchResult.DRM_UNKNOWN\n        return True\n", 
  "ozon_ru": "# -*-\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nstore_version = 3  # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2011-2013, Roman Mukhin <ramses_ru at hotmail.com>'\n__docformat__ = 'restructuredtext en'\n\nfrom contextlib import closing\ntry:\n    from urllib.parse import quote_plus\nexcept ImportError:\n    from urllib import quote_plus\n\nfrom qt.core import QUrl\n\nfrom calibre import browser, url_slash_cleaner\nfrom calibre.ebooks.chardet import xml_to_unicode\nfrom calibre.gui2 import open_url\nfrom calibre.gui2.store import StorePlugin\nfrom calibre.gui2.store.search_result import SearchResult\nfrom calibre.gui2.store.web_store_dialog import WebStoreDialog\n\nshop_url = 'http://www.ozon.ru'\n\n\ndef parse_html(raw):\n    try:\n        from html5_parser import parse\n    except ImportError:\n        # Old versions of calibre\n        import html5lib\n        return html5lib.parse(raw, treebuilder='lxml', namespaceHTMLElements=False)\n    else:\n        return parse(raw)\n\n\ndef search(query, max_results=15, timeout=60):\n    url = 'http://www.ozon.ru/?context=search&text=%s&store=1,0&group=div_book' % quote_plus(query)\n\n    counter = max_results\n    br = browser()\n\n    with closing(br.open(url, timeout=timeout)) as f:\n        raw = xml_to_unicode(f.read(), strip_encoding_pats=True, assume_utf8=True)[0]\n        root = parse_html(raw)\n        for tile in root.xpath('//*[@class=\"bShelfTile inline\"]'):\n            if counter <= 0:\n                break\n            counter -= 1\n\n            s = SearchResult(store_name='OZON.ru')\n            s.detail_item = shop_url + tile.xpath('descendant::a[@class=\"eShelfTile_Link\"]/@href')[0]\n            s.title = tile.xpath('descendant::span[@class=\"eShelfTile_ItemNameText\"]/@title')[0]\n            s.author = tile.xpath('descendant::span[@class=\"eShelfTile_ItemPerson\"]/@title')[0]\n            s.price = ''.join(tile.xpath('descendant::div[contains(@class, \"eShelfTile_Price\")]/text()'))\n            s.cover_url = 'http:' + tile.xpath('descendant::img/@data-original')[0]\n            s.price = format_price_in_RUR(s.price)\n            yield s\n\n\nclass OzonRUStore(StorePlugin):\n\n    def open(self, parent=None, detail_item=None, external=False):\n        url = detail_item or shop_url\n        if external or self.config.get('open_external', False):\n            open_url(QUrl(url_slash_cleaner(url)))\n        else:\n            d = WebStoreDialog(self.gui, shop_url, parent, url)\n            d.setWindowTitle(self.name)\n            d.set_tags(self.config.get('tags', ''))\n            d.exec_()\n\n    def search(self, query, max_results=15, timeout=60):\n        for s in search(query, max_results=max_results, timeout=timeout):\n            yield s\n\n\ndef format_price_in_RUR(price):\n    '''\n    Try to format price according ru locale: '12 212,34 \u0440\u0443\u0431.'\n    @param price: price in format like 25.99\n    @return: formatted price if possible otherwise original value\n    @rtype: unicode\n    '''\n    price = price.replace('\\xa0', '').replace(',', '.').strip() + ' py6'\n    return price\n\n\nif __name__ == '__main__':\n    import sys\n    for r in search(sys.argv[-1]):\n        print(r)\n"
}